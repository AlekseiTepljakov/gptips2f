function s = gpsym(gp, expr)
%GPSYM Compatibility function for MATLAB pre-R2017b and post-R2018a
%The GP structure must be known to GPSYM otherwise it will not be able
%to differentiate between symbolic names found in the expressions

% Known functions that should be excluded from becoming symbols
known_fun = {'abs' 'acos' 'acosd' 'acosh' 'acot' 'acotd' 'acoth' 'acsc' ...
    'acscd' 'acsch' 'adjoint' 'airy' 'and' 'angle' 'any' 'asec' 'asecd' ...
    'asech' 'asin' 'asind' 'asinh' 'atan' 'atan2' 'atan2d' 'atand' ...
    'atanh' 'bernoulli' 'bernstein' 'bernsteinMatrix' 'besselh' ...
    'besseli' 'besselj' 'besselk' 'bessely' 'beta' 'cat' 'catalan' ...
    'ceil' 'charpoly' 'chebyshevT' 'chebyshevU' 'checkUnits' 'chol' ...
    'coeffs' 'collect' 'colspace' 'combine' 'compose' 'cond' 'conj' ...
    'cos' 'cosd' 'cosh' 'coshint' 'cosint' 'cospi' 'cot' 'cotd' 'coth' ...
    'csc' 'cscd' 'csch' 'ctranspose' 'cumprod' 'cumsum' 'curl' ...
    'daeFunction' 'dawson' 'deg2rad' 'det' 'diag' 'diff' 'dilog' ...
    'dirac' 'display' 'divergence' 'divisors' 'ei' 'eig' 'eliminate' ...
    'ellipj' 'ellipke' 'ellipticCE' 'ellipticCK' 'ellipticCPi' ...
    'ellipticE' 'ellipticF' 'ellipticK' 'ellipticNome' 'ellipticPi' ...
    'eq' 'equationsToMatrix' 'erf' 'erfc' 'erfcinv' 'erfi' 'erfinv' ...
    'euler' 'eulergamma' 'exp' 'expand' 'expint' 'expm' 'factor' ...
    'factorial' 'factorIntegerPower' 'fibonacci' 'find' 'findSymType' ...
    'finverse' 'fix' 'floor' 'fortran' 'fourier' 'frac' 'fresnelc' ...
    'fresnels' 'functionalDerivative' 'funm' 'gamma' 'gammaln' 'gbasis' ...
    'gcd' 'ge' 'gegenbauerC' 'gradient' 'gt' 'harmonic' 'has' ...
    'heaviside' 'hermiteForm' 'hermiteH' 'hessian' 'horner' 'htrans' ...
    'hurwitzZeta' 'hypergeom' 'hypot' 'ifourier' 'igamma' 'ihtrans' ...
    'ilaplace' 'imag' 'in' 'incidenceMatrix' 'int' 'inv' 'isAlways' ...
    'isequal' 'isequaln' 'ismember' 'isnan' 'isolate' 'iztrans' ...
    'jacobiAM' 'jacobian' 'jacobiCD' 'jacobiCN' 'jacobiCS' 'jacobiDC' ...
    'jacobiDN' 'jacobiDS' 'jacobiNC' 'jacobiND' 'jacobiNS' 'jacobiP' ...
    'jacobiSC' 'jacobiSD' 'jacobiSN' 'jacobiZeta' 'jordan' 'kron' ...
    'kroneckerDelta' 'kummerU' 'laguerreL' 'lambertw' 'laplace' ...
    'laplacian' 'lcm' 'ldivide' 'le' 'legendreP' 'lhs' 'limit' ...
    'linsolve' 'log' 'log10' 'log2' 'logint' 'logm' 'lt' 'lu' 'max' ...
    'meijerG' 'min' 'minpoly' 'minus' 'mixedUnits' 'mldivide' 'mod' ...
    'mpower' 'mrdivide' 'mtimes' 'nchoosek' 'ndims' 'ne' 'nextprime' ...
    'nnz' 'nonzeros' 'norm' 'not' 'nthprime' 'nthroot' 'null' 'numden' ...
    'numel' 'odeToVectorField' 'or' 'orth' 'pade' 'partfrac' 'permute' ...
    'piecewise' 'pinv' 'plus' 'pochhammer' 'poles' 'polylog' ...
    'polynomialDegree' 'polynomialReduce' 'potential' 'power' ...
    'powermod' 'prevprime' 'prod' 'psi' 'qr' 'quorem' 'rad2deg' 'rank' ...
    'rdivide' 'real' 'rectangularPulse' 'reduceDAEIndex' ...
    'reduceDAEToODE' 'reduceDifferentialOrder' 'reduceRedundancies' ...
    'rem' 'reshape' 'resultant' 'rewrite' 'rhs' 'root' 'round' 'rref' ...
    'rsums' 'sec' 'secd' 'sech' 'series' 'sign' 'signIm' 'simplify' ...
    'simplifyFraction' 'sin' 'sinc' 'sind' 'single' 'sinh' 'sinhint' ...
    'sinint' 'sinpi' 'smithForm' 'sort' 'sqrt' 'sqrtm' 'ssinint' ...
    'subexpr' 'subs' 'sum' 'svd' 'symprod' 'symsum' 'tan' 'tand' 'tanh' ...
    'taylor' 'times' 'toeplitz' 'transpose' 'triangularPulse' 'tril' ...
    'triu' 'uminus' 'uplus' 'vectorPotential' 'vertcat' 'vpa' ...
    'vpaintegral' 'vpasolve' 'whittakerM' 'whittakerW' 'wrightOmega' ...
    'xor' 'zeta' 'ztrans'};

% Here we need to take into account that expr may be numeric in which
% case the str2sym function will fail. sym(), on the other hand, will
% return a symbolic object while converting a double prec. number to a
% fraction, if possible.
% TODO: Possible bug hidden in here? Must test.
if ~exist('str2sym', 'file') || isnumeric(expr)
    s = sym(expr);
else
    
    funcs = [gp.nodes.functions.name gp.nodes.adf.syms]; % Combine all
    funcs = unique(funcs); % Remove repeating entries
    funcs = setdiff(funcs, known_fun); % Remove fundamental functions
    for k=1:numel(funcs)
        assignin('caller', funcs{k}, sym(funcs{k}));
    end
    
    % Finally, create the symbolic expression
    s = str2sym(expr);
end

end

